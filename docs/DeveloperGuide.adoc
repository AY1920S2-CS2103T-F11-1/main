= Calgo - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S2-CS2103T-F11-1/main

By: `Team F11-1`      Since: `March 2020`      Licence: `MIT`

*Table of Contents*:

== About this guide

This Developer Guide is a document to guide future software developers of the Calgo App by providing a sufficient and comprehensible overview of the project. +

While we aim to provide a reasonable amount of depth, do keep in mind that the goal of this document is not to serve as a replacement for reading the actual code. +

Welcome on-board the Software Development Team for Calgo! Together, we will inspire a healthier lifestyle!

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

[TIP]
The `.puml` files used to create diagrams in this document can be found in
the link:{repoURL}/tree/master/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

The *_Architecture Diagram_* given above describes the high-level design of the Calgo Application. From now on, all
instances of Calgo Application will be referred to as App.
Given below is a quick overview of each component.

The `Main` component comprises of two classes called link:{repoURL}/blob/master/src/main/java/life/calgo/Main.java[`Main`] and
link:{repoURL}/blob/master/src/main/java/life/calgo/MainApp.java[`MainApp`].
This component is responsible for:

* Launching App: Initializes the other components in the correct sequence, and connects them up with each other.
* Exiting App: Shuts down the components and invokes cleanup method where necessary.

<<<

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
In particular, the `LogsCenter` class plays an important role at the architecture level:

* `LogsCenter` : Writes log messages to the App's log file, for various classes.

The rest of the App comprises of four components.

* <<Design-Ui,*`UI`*>>: The User Interface (UI).
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: The in-memory representation of the App data.
* <<Design-Storage,*`Storage`*>>: The file manager for reading from and writing to the hard disk.

Each of the four components:

* Defines its _Application Programming Interface (API)_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines its API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

<<<

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete n/Apple`.

.Component interactions for `delete n/Apple` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

<<<

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/tree/master/src/main/java/life/calgo/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `FoodListPanel`, `DailyListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/blob/master/src/main/java/life/calgo/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/blob/master/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component:

. Executes user commands using the `Logic` component.
. Listens for changes to `Model` data so that the UI can be updated with the modified data.

<<<

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/blob/master/src/main/java/life/calgo/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `CalgoParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a food).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete n/Apple")` API call.

.Interactions Inside the Logic Component for the `delete n/Apple` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

<<<

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/blob/master/src/main/java/life/calgo/model/Model.java[`Model.java`]

. `Model` stores user's preferences in a `UserPref` object.
. `Model` also stores Food Record data.
. This component exposes both `ObservableList<Food>` and `ObservableList<ConsumedFood>`. The data stored in
these two list objects is reflected in UI. Therefore, any changes made to the data in these lists are shown in the UI in
real-time.
. To update the `Model` (and hence reflect the changes in the UI), `Food` attributes need to satisfy certain `Predicates`, which represent these changes.
. This component does not depend on any of the other three components.

[NOTE]
To make `Model` follow the Object-Oriented Paradigm (OOP) more closely,
we can store a `Tag` list in `Food Record`, which `Food` objects can reference.
This would allow `Food Record` to only require one `Tag` object per unique `Tag`,
instead of each `Food` needing their own `Tag` object.
An example of how such a model may look like is given in the below diagram. +
 +

.Structure of the Model Component
image::BetterModelClassDiagram.png[]

<<<

// tag::storagecomponent[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/blob/master/src/main/java/life/calgo/storage/Storage.java[`Storage.java`]

The `Storage` component allows us to save `FoodRecord`, `UserPref`, `Goal`, and `ConsumptionRecord`  data in json format onto the disk, and read them back later on during the next session.

This would facilitate the following functions:

. Load past user App data and preferences.
. Generate and save insights reports based on previously and currently recorded user consumption.
. Generate and save a user-friendly version of the accumulated `FoodRecord`.

// end::storagecomponent[]

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `life.calgo.commons` package.

<<<

== Implementation

This section describes some noteworthy details on how certain features are implemented.

//tag:: Report[]
[[Implementation-InsightsReport]]
=== Generate insights report
This feature allows a user to generate a report that contains statistics and deliverable insights based on
personal food consumption patterns.

The functionality can be invoked by entering the `report d/DATE` command.
This command generates a report that is based on the food consumed by
the user on the specified date.

==== Implementation
The specified feature is facilitated by `ReportGenerator` class in the `Storage` component.
In this section, the implementation features of the `ReportGenerator` class will be further explained.

`ReportGenerator` class implements the following operation:

* `ReportGenerator#generateReport()` - Creates report containing an analysis of all food consumed by user on the
given date when inputting the `report` command.

Whenever the `report d/DATE` command is given by the user, the `ReportGenerate#generateReport()` operation is called.

<<<

The following sequence diagram illustrates the top-level execution of the `generateReport()` operation:

image::ReportFeatureSequenceDiagram.png[]

Step 1: User inputs `report d/2020-03-27` to generate the insights report based on food consumption of 27 March 2020. +

Step 2: This input is saved as a `String` and passed into the `LogicManager`. +

Step 3: The `String` input is parsed by `CalgoParser`, which removes the "d/" prefix tag and sends
the date input to `ReportCommandParser`. +

Step 4: Once the `ReportCommandParser` checks that the given date is valid, it creates a `ReportCommand` object and
returns it to `LogicManager`.

Step 5: `LogicManager` then executes the `ReportCommand`.

Step 6: From `Model`, `ReportCommand` retrieves the `DailyFoodLog` object that stores all `Food` consumed on the input date.

Step 7: From `Model`, `ReportCommand` also retrieves `DailyGoal` object, which stores the daily number of calories the user wants to consume.

Step 8: With the relevant objects retrieved from Steps 6 and 7, `ReportCommand` constructs a
`ReportGenerator` object.

Step 9: Using the `ReportGenerator` object, `ReportCommand` calls `#generateInsights()`, which prints metainformation
, food-wise statistics, aggregate statistics and insights based on the `DailyFoodLog` of the input date.

Step 10: This newly generated report is saved in the `/reports` folder. If the report is successfully generated,
the `CommandResult` is true. Otherwise, it is false. This `CommandResult` object is finally returned to `LogicManager`,
to signify the end of the command.

<<<

==== Design considerations

===== Aspect: How generate report executes

* *Alternative 1 (current choice):* Print insights into a .txt file.

** Pros: The implementation allows users to easily edit the contents of the report should they have realised they
did not log in certain food items on that day.
** Cons: Users could cheat by modifying values in the report. This defeats the purpose of the report to improve their
self-awareness of their food consumption patterns.

* *Alternative 2:* Print insights into a pdf file.
** Pros: The insights appear more legitimate and neatly formatted.

** Cons: Requires use of external libraries, which occupy memory of the App. PDF files generally require
more memory than .txt files as well.

==== Summary
The following activity diagram summarizes what happens when user executes a `report d/DATE` command: +

.Activity Diagram for Report command
image::ReportActivityDiagram.png[]

//tag:: Goal[]
[[Implementation-GoalFeature]]
=== Setting Goal Feature

// tag::categoricalsubstringfindsearch[]
[[Implementation-FindList]]
=== Searching for specific `Food` via categories and substrings
(by Eugene)

This section addresses how the `find` and `list` commands work. As they are complementary in their functions during the search process, both `find` and `list` commands will be explained together here for better coherence.

The `find` command allows us to search through the `FoodRecord` (via categorical or substring search) based on what the user enters for the `Prefix`. Users may enter one and only one `Prefix`. The search results can then be displayed in the GUI's `Food Record`.

Meanwhile, the `list` command allows us to reset the GUI's `Food Record` to once again show all entries in lexicographical order. This can be thought of as the reverse of a `find` command. However, unlike the `find` command, the `list` command does not use any `Prefix`, and ignores any input after its command word.

[NOTE]
`Prefix` here indicates which `Food` attribute we are interested in. Categorical search finds `Food` objects with values that match the user-specified value representing one of the nutritional categories (`Calorie`, `Protein`, `Carbohydrate`, or `Fat`). Meanwhile, substring search finds matches for the user-entered substring in any part of the the `Name` or in any of the `Tag` objects belonging to the `Food` objects.

[NOTE]
For more information on lexicographical ordering, please refer to its relevant section <<Implementation-LexicographicalOrder, here>>.

The above commands rely on the `FindCommand` and `ListCommand` objects respectively. Objects of both classes use a `Predicate<Food>` object to filter through the current `Food` objects, where `Food` objects will be displayed in the GUI's `Food Record` should they evaluate these predicates to be true.

==== Implementation
To search via a particular `Food` attribute, we use a `FindCommandParser` to create the corresponding `Predicate<Food>` based on which `Food` attribute the `Prefix` entered represents. This predicate is then used to construct a new `FindCommand` object, which changes the GUI display when executed. +

The class diagram below shows the relevant `Predicate<Food>` classes used in the construction of `FindCommand` objects.

.Class Diagram showing the relevant predicates used in constructing `FindCommand` objects
image::FindListCommandPredicateClassDiagram.png[]

As seen in the above class diagram, each `Predicate<Food>` is indeed representative of either `Name`, `Calorie`, `Protein`, `Carbohydrate`, `Fat`, or `Tag`. Moreover, it should be noted that each of these predicates test against a `Food` object, and therefore have a dependency on `Food`.

The sequence diagram below demonstrates how the `find` command works, for both categorical and substring search:

.Sequence Diagram for `find` command: categorical search and substring search
image::FindSequenceDiagram.png[]

[NOTE]
The lifeline for the both of the `FindCommandParser` objects, and both of the `FindCommand` objects should end at their destroy markers (X) but due to a limitation of PlantUML, the lifelines reach the end of diagram.

From the above, it is clear that both categorical search and substring search of the `find` command have similar steps: +

Step 1: `LogicManager` executes the user input, using `CalgoParser` to realise this is a `find` command, and a new `FindCommandParser` object is then created. +

Step 2: The `FindCommandParser` object parses the user-entered arguments that come with the `Prefix`, creating a `Predicate<Food>` object based on which `Food` attribute the `Prefix` represents.

- In the above diagram examples, a `ProteinContainsKeywordsPredicate` object is created for the categorical search via `Protein` while a `NameContainsKeywordsPredicate` object is created for the substring search via `Name`. +

Step 3: This `Predicate<Food>` object is then used to construct a new `FindCommand` object, returned to `LogicManager`. +

Step 4: `LogicManager` calls the `execute` method of the `FindCommand` created, which filters for `Food` objects that evaluate the predicate previously created to be true. It then returns a new `CommandResult` object reflecting the status of the execution. These changes are eventually reflected in the GUI.

The `find` command therefore searches through the existing `FoodRecord` and then displays the relevant search results in the GUI's `Food Record`. To once again show all `Food` entries in the display, we use the `list` command.

In constrast to `FindCommand`, the `ListCommand` constructor takes in no arguments and simply uses the predicate `Model.PREDICATE_SHOW_ALL_FOODS` to always show all `Food` entries in its `execute` method. This is described by the sequence diagram below:

.Sequence Diagram for `list` command
image::ListSequenceDiagram.png[]
[NOTE]
The lifeline for the `ListCommand` object should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.


How the `list` command works:

Step 1: `LogicManager` executes the user input, using `CalgoParser` to realise this is a `list` command, and a new `ListCommand` object is created. +

Step 2: `LogicManager` then calls the `execute` method of this `ListCommand`, which uses `Model.PREDICATE_SHOW_ALL_FOODS` to evaluate to true for all `Food` objects in the `FoodRecord`.

Step 3:  `LogicManager` then returns a new `CommandResult` object to reflect the status of the execution, in the GUI. The GUI's `Food Record` reflects the above changes to show all `Food` entries once again.

==== Design considerations

===== Aspect: Predicate construction source.

* **Alternative 1 (current choice):** Each `Predicate<Food>` is constructed using a new object of type either `Name`, `Calorie`, `Protein`, `Carbohydrate`, `Fat`, `Tag`.
** Pros:
- Defensive programming by building new objects rather than relying on mutable sources.
- Can reuse existing code and classes like ArgumentMultimap and their methods.
- Models objects well to reflect the real-world.
** Cons:
- May be more resource-intensive than other alternatives.
- New developers may not find this intuitive.
* **Alternative 2:** Each `Predicate<Food>` is created using a `String` which represents the keywords.
** Pros:
- Easier to implement with fewer existing dependencies.
- Less resource-intensive.
** Cons:
- More prone to bugs.
- Difficult to ascertain which `Food` attribute it actually represents.
- More difficult to debug as `String` type is easily modified.
- Does not reflect good OOP practices

===== Aspect: Enabling substring search.

* **Alternative 1 (current choice):** Allow substring search for both `Name` and `Tag`
** Pros:
- Improves user experience.
- Can reuse common code as the approach for both `Name` and `Tag` are similar.
- Generally easy to implement substring finding.
- Can use regular expressions if needed, which are powerful and suitable for our purpose.
** Cons:
- Requires good understanding of the original project.
- Need to know the `String` type, regular expressions, and their implications.
- Need to implement searching via multiple types of `Food` attributes and hence introduces more dependencies.
- Need to implement a new `Parser` class to detect each relevant `Prefix`.
* **Alternative 2:** Only allow exact word matches for `Name` and `Tag`
** Pros:
- Can simply reuse large parts of the original project's existing code.
- Less prone to bugs.
- Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
** Cons:
- Diminishes user experience.
- May not fully satisfy the user requirements.
- Need to implement searching via multiple types of `Food` attributes and hence introduces more dependencies.
- Need to implement a new `Parser` class to detect each relevant `Prefix`.

==== Summary

In essence, this section focuses on searching which is implemented via `find` and `list` commands. +

The `find` command performs a categorical search if a value from a nutritional category (`Calorie`, `Protein`, `Carbohydrate`, `Fat`) is specified. Otherwise, a substring search is performed to find `Food` objects that contain the entered substring in their `Name` or in one of their `Tag` s. These rely on the `Predicate<Food>` object used in constructing the `FindCommand`, which depend on the `Prefix` entered by the user. +

Meanwhile, the `list` command simply uses the predicate already defined in `Model` to display all `Food` objects. +

The above can be summarised in the activity diagram below:

.Activity Diagram for Searching
image::FindListCommandActivityDiagram.png[]

// end::categoricalsubstringfindsearch[]

// tag::lexicographicalordering[]
[[Implementation-LexicographicalOrder]]
=== Lexicographical `Food` order
(by Eugene)

This section addresses how the GUI `Food Record` entries appear in lexicographical order, which is an effect of sorting `Food` objects in the `FoodRecord`.

Over time, users will eventually have many `Food` entries -- these should be sorted for a better experience. Intuitively, the lexicographical order is the most suitable here.

In essence, `Food` objects are sorted by the `UniqueFoodList` (which is inside `FoodRecord`).
Sorting is performed each time `Food` object(s) are newly added to the `UniqueFoodList`, or during the initialisation of the `UniqueFoodList` upon App start-up.
There is no need to re-sort when a `Food` object is deleted or edited as the order is maintained.

[NOTE]
For a better understanding of adding and editing `Food` objects using the `update` command, please refer to its relevant section <<Implementation-SmartUpdate, here>>.
[NOTE]
Although the the `list` command changes the GUI `Food Record` display, it does not actually perform sorting. It simply resets the GUI `Food Record` to show all `Food` entries, and is usually used after a `find` command. You can read more about them <<Implementation-FindList, here>>.

==== Implementation

The `UniqueFoodList` is able to sort `Food` objects because the `Food` class implements the `Comparable<Food>` interface.
This allows us to specify the lexicographical order for sorting `Food` objects via their `Name`, using the following compareTo method in the `Food` class:
[source,java]
----
public int compareTo(Food other) {
    String currentName = this.getName().toString();
    String otherName = other.getName().toString();
    return currentName.compareTo(otherName);
}
----

How the sorting process works:

* When the App starts up, a new `UniqueFoodList` is created from the source json file (if available) or otherwise the default entries, and the created `Food` objects are sorted as they are added to it.
* Existing `Food` objects are therefore arranged in lexicographic order by `Name`.
* Thereafter, `UniqueFoodList` sorts the `Food` objects whenever new `Food` objects are added.

It should be noted that sorting is only performed by the `addFood` and `setFoods` method of the `UniqueFoodList`, which calls the `sortInternalList` method. Not to be confused, the `setFood` method, which is used when a `Food` object is edited, does not perform any sorting. +

The sequence diagram below shows how the lexicographical ordering is performed when Calgo starts up:

.Lexicographical Ordering Sequence Diagram for App Start-up
image::LexicographicalOrderingStartupSequenceDiagram.png[]

Based on the above diagram, when Calgo starts: +

Step 1: We initialise the `ModelManager` object. For this, we use previously stored user data if available (by reading in from the source json files). Otherwise, we use the default Calgo `Food` entries. +

Step 2: Before we can finish constructing a new `ModelManager` object, we require the creation of a new `FoodRecord` object which in turn requires the creation of a new `UniqueFoodList` object. +

Step 3: Once `UniqueFoodList` is constructed, we introduce the initialising data into it using the `setFoods` method. This calls the `sortInternalList` method, which sorts the newly added `Food` objects in the `ObservableList<Food>` contained in `UniqueFoodList`, according to the specified lexicographical order (defined in the `Food` class).


Moving on, the sequence diagram below (which is a reference frame omitting irrelevant `update` command details) describes the lexicographical sorting process when `Food` objects are added (not edited) using the `update` command:

.Lexicographical Ordering Sequence Diagram for Updating
image::LexicographicalOrderingUpdateSequenceDiagram.png[]

[NOTE]
This is in a reference frame as it is reused in the `update` section <<Implementation-SmartUpdate, here>>)


Here, the diagram describes what happens after parsing the user input and creating an `UpdateCommand` object. Since the `Food` entered by the user is an entirely new `Food` object without a `Name`-equivalent `Food` existing in the `UniqueFoodList`:

Step 1: We call the respective `addFood` and `add` methods as seen in the diagram, eventually adding the `Food` object into the `UniqueFoodList` and arriving at its `sortInternalList` method call. +

Step 2: The `sortInternalList` method then sorts the `Food` objects in the `ObservableList<Food>` contained in `UniqueFoodList`, according to the specified lexicographical order defined in the `Food` class.

[NOTE]
During an `update` command, we do not perform sorting if the user enters a `Food` object that already has an existing counterpart with an equivalent `Name` in the `UniqueFoodList`.

Any re-ordering will eventually be reflected in the GUI, facilitated by the following (in the case of an `update` command) or otherwise something similar:
[source,java]
----
model.updateFilteredFoodRecord(Model.PREDICATE_SHOW_ALL_FOODS);
----

<<<

==== Design considerations

===== Aspect: Frequency of sorting operation.

* **Alternative 1 (current choice):** Sort whenever a new `Food` is added or during App start-up.
** Pros:
- Guarantees correctness of sorting.
- Saves on computational cost by not sorting during deletion or edits as the order is preserved.
- Computational cost is not too expensive since the introduced `Food` objects usually come individually rather than as a collection (except during App start-up).
** Cons:
- Need to ensure implementations of various commands changing the `Model` are correct and do not interfere with the sorting process.
- May be computationally expensive if there are many unsorted `Food` objects at once, which is possible when Calgo starts up.
* **Alternative 2:** Sort only when calling the `list` command.
** Pros:
- Easier to implement with fewer existing dependencies.
- Uses less computational resources since sorting is only done when `list` command is called.
** Cons:
- Diminishes user experience.
- May be incompatible with certain `Storage` functions.
- May lead to bugs in overall product due to incompatible features.

===== Aspect: Data structure to store `Food` objects.

* **Alternative 1 (current choice):** Use `UniqueFoodList` to store all `Food` objects.
** Pros:
- Can reuse existing code, removing the need to maintain a separate list-like data structure.
- Based on existing code, any changes to the `Model` from the sorting process are automatically reflected in the GUI. This is very useful for testing and debugging manually.
** Cons:
- Many of the underlying `ObservableList` methods are built-in and cannot be edited. They are also difficult to understand for those unfamiliar. This can make development slightly trickier, especially in following certain software engineering principles.
* **Alternative 2:** Use a simpler data structure like an `ArrayList`.
** Pros:
- Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
** Cons:
- More troublesome as we require self-defined methods, abstracted over the existing ones. If not careful, these self-defined methods can possibly contain violations of certain software engineering principles, which may introduce regression in the future.
- May be inefficient in using resources.

<<<

==== Summary

The `UniqueFoodList` facilitates the lexicographical ordering of `Food` objects and hence how their respective entries appear in the GUI `Food Record`. This can be summarised in the activity diagram below:

.Activity Diagram for Lexicographical Ordering
image::LexicographicalOrderingActivityDiagram.png[]
// end::lexicographicalordering[]

// tag::exportfoodrecord[]
[[Implementation-Export]]
=== Exporting the current `FoodRecord` into a portable file
(by Eugene)

This section addresses how the `export` command works, creating a FoodRecord.txt file showing details of all the `Food` objects currently stored in the `FoodRecord`. The information is presently neatly in table form and the file is created in the `data/exports` folder.

The `export` command mainly uses an `ExportGenerator` object to generate the file. All formatting options and methods to write the contents of the file are included in the `ExportGenerator` class, which extends the `DocumentGenerator` class.

[NOTE]
You may find the `report` command similar as they both create a new file for the user. You can read more about it <<Implementation-InsightsReport, here>>.

==== Implementation

Most of the work in generating the file is done by the `generateExport` method of `ExportGenerator`. You can access the class to view its methods for writing the header and footer components, which are relatively easily to understand.

However, the methods for writing the file body is likely where some explaining is required. Here, the formatting of the table body is determined by the following:
[source,java]
----
    private static final int NAME_COLUMN_SIZE = 45;
    private static final int VALUE_COLUMN_SIZE = 20;
----
`NAME_COLUMN_SIZE` represents the allowed space for the `Name`. If a `Food` object has a `Name` which is too long, the `Name` will be truncated and continued on the following lines.
Meanwhile, `VALUE_COLUMN_SIZE` represents the allowed space for each nutritional value of `Calorie`, `Protein`, `Carbohydrate`, and `Fat` in the table. These are guaranteed to be within a length of 5 characters when parsing, and should not exceed the given space.

The nutritional values will always be shown in the first line of their respective `Food` object after its (possibly truncated) `Name`. This is facilitated by the `printBody` method of `ExportGenerator`, which calls its `printBodyComponent` method and subsequently its `generateFinalisedEntryString` method, which performs the truncation and amendment of the `Name` as necessary.

Moving on, the sequence diagram below demonstrates how the `export` command works to create the user copy of the current `FoodRecord`:

.Sequence Diagram for `export` command: generating FoodRecord.txt
image::ExportSequenceDiagram.png[]

[NOTE]
The lifeline for the `ExportCommand` object and that of the `ExportGenerator` object should end at their destroy markers (X) but due to a limitation of PlantUML, the lifelines reach the end of diagram.

From the above, creating FoodRecord.txt involves the following steps:

Step 1: `LogicManager` executes the user input, using `CalgoParser` to realise this is a `export` command, and a new `ExportCommand` object is created. +

Step 2: LogicManager then calls the `execute` method of this `ExportCommand` object. This results in a call to the `Model` to get the current `FoodRecord`, which is used to construct a new `ExportGenerator` object. The `ExportGenerator` is responsible for creating the FoodRecord.txt file and writing to it.

Step 3: `ExportCommand` then calls the `generateExport` method of `ExportGenerator`, writing the required parts to the file. This returns a boolean indicating whether the file creation and writing are successful.

Step 4: A new `CommandResult` object indicating the result of the execution is then constructed and reflected in the GUI.

==== Design considerations

===== Aspect: Type of file to create.

* **Alternative 1 (current choice):** Create a .txt file to represent the `FoodRecord`.
** Pros:
- Satisfies user requirements by allowing editing of the file to include custom entries.
** Cons:
- Need to define new classes and methods for file writing, which may introduce more dependencies.
- May be more resource-intensive than other alternatives.
- New developers may be unfamiliar with `String` manipulation and regular expressions.
* **Alternative 2:** Create a .pdf file to represent the `FoodRecord`
** Pros:
- The contents appear to be more legitimate.
- Can use external libraries for convenience.
- May be less resource-intensive.
** Cons:
- May not satisfy user requirements as the file cannot be edited easily.
- May introduce more bugs, additional dependencies, and become prone to external factors.
- More difficult to debug due to lack of familiarity with external libraries.
- May require more space.

===== Aspect: Abstraction for `ExportGenerator` and `ReportGenerator`.

* **Alternative 1 (current choice):** Create `DocumentGenerator` abstract class which both `ExportGenerator` and `ReportGenerator` extends.
** Pros:
- Good OOP practice, following its principles.
- Allows for code reuse and neater code.
- Able to apply concepts of polymorphism, if required.
- May be now easier to debug.
** Cons:
- Need to define new class, possibly introducing more dependencies.
- Need to identify what is common to both `ExportGenerator` and `ReportGenerator`.
* **Alternative 2:** Use an interface which both classes will implement.
** Pros:
- Similar to Alternative 1.
** Cons:
- Does not allow methods to be defined in the interface. (Some exceptions: default methods, etc)
- May need to repeat definitions which may be the same for both classes.
* **Alternative 3:** Do not use an interface or abstract class.
** Pros:
- Requires less effort.
- Does not introduce additional dependencies.
** Cons:
- Unable to reap benefits of the above alternatives.

==== Summary

In short, this section addresses how users are able to obtain an editable copy of the current `FoodRecord` using the `export` command.

The `export` command largely relies on the `ExportGenerator` class, which facilitates creating the file and writing to it.

The above can be summarised in the activity diagram below:

.Activity Diagram for Searching
image::ExportActivityDiagram.png[]

// end::exportfoodrecord[]


[[Implementation-ConsumptionManagement]]
=== `Food` consumption management

(by Ruicong)


In Calgo, you will find that there is a date associated with each list of `ConsumedFood`.
When adding food to be consumed, removing food, or displaying food consumed on certain days,
a `FilteredList` will be populated with relevant `ConsumedFood`.

==== Implementation
The `nom`, `vomit` and `stomach` commands are facilitated by the `FoodRecord`.  +
`FoodRecord` contains a `UniqueDateToLogMap`, which maps a `LocalDate` to a `DailyFoodLog`. +
`DailyFoodLog` contains a `LinkedHashMap` storing `Food` in the sequence that they were consumed and maps those `Food` to a `Double` portion.

This section covers how the `nom` command is implemented. The `vomit` and `stomach` commands work in very similar way, hence their implementation is omitted for brevity.

A top-level illustration of the execution of a `nom` command is given in the sequence diagram below:

image:NomSequenceDiagram.png[]

Step 1: User enters a command, which is saved as a `String` and passed into the `LogicManager`. +
Step 2: The `String` cascades down the layers of abstraction until `NomCommandParser` handles it and creates a
`DailyFoodLog` which reflects the consumption. +
Step 3: A `NomCommand` is created and executed, updating both `ModelManager` and `FoodRecord` about the consumed food. +
Step 4: A `FilteredList` in `ModelManger` will then check with `FoodRecord` to create `ConsumedFood` items to display in the Graphical User Interface (GUI). +
Step 5: The GUI automatically detects changes in `FilteredList` and refreshes to display updated content.

<<<

==== Design considerations

===== Aspect: How `nom` executes

* **Alternative 1 (current choice):** Create a new `DailyFoodLog` to pass into `ModelManager` and `FoodRecord`.
** Pros: Maintain comprehensive layers of abstraction and allows code to be easily testable.
** Cons: Difficult for newcomers or even existing users to trace because of long execution path.

* **Alternative 2:** Bypass `ModelManager` or even not use `FoodRecord` for storage of data during runtime by allowing everything to be done
from parser.
** Pros: Reduce dependencies on `ModelManager` and `FoodRecord`, and make code contained in a single class file easier to navigate.
** Cons: Violates layers of abstraction set in place by previous structure of AddressBook3. Violates Single Responsibility Principle and reduce
cohesiveness of code.

===== Aspect: Data structure to support the consumption commands

* **Alternative 1 (current choice):** Use a single `FilteredList` to store food for any day by repopulating it each time
a consumption related command is used.
** Pros: Only uses a single `FilteredList`, so it is clear which list you are using for display.
** Cons: May have performance issue in terms of speed when there are too many entries.

* **Alternative 2:** Use a `FilteredList` for each date, to store food consumed on that date.
** Pros: Faster retrieval for display of `ConsumedFood` items. However, under practical circumstances, the difference is negligible.
** Cons: May have performance issue in terms of storage because it requires many lists to be stored in addition to `LinkedHashMap`
in `DailyFoodLog` for each `LocalDate`.

==== Summary

The `nom` command adds a `Food` item consumed by the user into the `stomach`. The following activity diagram summarizes what happens when the user executes a `nom` command.

.Activity Diagram for Nom
image::NomActivityDiagram.png[]

[[Implementation-SmartUpdate]]
=== Updating the `FoodRecord`
This section addresses how the `update` command works.

The `update` command allows the user to update the `FoodRecord` by either updating a new `Food` into the `FoodRecord` or updating the
nutritional values of an existing `Food` in the `FoodRecord`.

From the user's perspective, the `update` command decides whether to
override an existing `Food` in the `FoodRecord` with new values, or create a new `Food` in the `FoodRecord` for them.

For better user experience, the `Name` required in the `update` command is case-insensitive. This means that if "Apple" already exists in the
`FoodRecord`, an `update` command with "apple" as the `Name` will result in nutritional values of "Apple" in the `FoodRecord` being updated,
instead of a new `Food` with `Name` "apple" being created in the `FoodRecord`

On top of this, for all new `Food` being updated into the `FoodRecord` with the `update` command, the `Name` entry of the `Food` updated into the `FoodRecord`
will be formatted to proper case. This means that if the user updates a new q into the `FoodRecord` with the `Name` as "char kuay teow", the `Food` that
is stored in the `FoodRecord` will be of `Name` "Char Kuay Teow".


[NOTE]
When a new Food is updated into the FoodRecord, the FoodRecord is sorted in lexicographical order. For more information on how this is implemented,
please refer to its relevant section <<Implementation-LexicographicalOrder, here>>.


==== Implementation

The `update` command is facilitated by the FoodRecord which contains a UniqueFoodList which stores all the Food in the FoodRecord.
This command either adds a new Food into this UniqueFoodList or edits the nutritional values of an existing Food in the UniqueFoodList.
An additional operation is implemented to help with this:

* `FoodRecord#hasFood()` - Checks if there is an existing `Food` in `FoodRecord` by checking if there is any `Food` in the FoodRecord
with the same `Name`.

This operation was exposed in the `Model` interface as `Model#hasFood()` and allows the `UpdateCommand` to decide whether to
add or edit `Food` in the `UniqueFoodList`.

The following sequence diagram shows how the `update` operation works in both cases:

.Sequence Diagram for Update command (to be updated)
image::UpdateSequenceDiagram.png[]
NOTE: The lifeline for `UpdateCommandParser` and `UpdateCommand` should end at their destroy markers (X) but due to a limitation of PlantUML, the lifelines reach the end of diagram.

How the `update` command works:

Step 1: LogicManager executes the user input of `update n/apple cal/52 p/2 c/14 f/1", using CalgoParser to realise this is
an update command and creates a new UpdateCommandParser object.

Step 2: `UpdateCommandParser` then parses the arguments provided by `CalgoParser` with the `parse` method.
During this parsing process, `UpdateCommandParser` calls the `covertToTitleCase` method on the `Name` argument, converting it
to proper case.

Step 3: `UpdateCommandParser` then creates a new `UpdateCommand` object, which `LogicManager` calls the execute method with this object
as an argument.

Step 4: `UpdateCommand` now checks if there exists an existing `Food` in the `FoodRecord` by calling `Model` 's
`hasFood` method, which checks if there is any Food in `FoodRecord` 's UniqueFoodList with the same `Name`.

Step 5:

* Scenario 1:
If Food already exists in the `FoodRecord`:
** Model calls the `getExistingFood` method with the user inputted Food
as a parameter to get the existing Food, `existingFood` in the `UniqueFoodList`. It thens call the setFood method to replace the
existing Food in the UniqueFoodList with the new `Food` which contains new nutritional values.

* Scenario 2:
If Food does not exist in `FoodRecord`:
** This scenario is handled by the Lexicographical Ordering feature. Please refer to its relevant section <<Implementation-LexicographicalOrder, here>>.
** Model calls the `addFood` method with the user inputted `Food` as a parameter to add the new `Food` into the `UniqueFoodList` in `FoodRecord`
** After the `Food` is added into the `UniqueFoodList`, the `UniqueFoodList` is also sorted in lexicographical order.

Step 6: A new `CommandResult` object is then created and returned back to `LogicManager`.

<<<

==== Design considerations

===== Aspect: Updating the `FoodRecord` when there is an existing `Food` item in `FoodRecord`

* *Alternative 1 (current choice):* Overrides the existing `Food` item with the new `Food` item
** Pros:
*** No need for an additional command of `edit` just for the user to edit an existing `Food` item in the `FoodRecord`.
** Cons:
*** Might not be intuitive for the user since the word "update" is generally assumed to be for editing something only and not necessarily adding something.
*** May result in additional performance overhead.

* *Alternative 2:* Informs the user that there is already an existing `Food` item, and direct him to use another command `edit` to edit the existing `Food` instead.
** Pros:
*** More intuitive for user, since he might not know that he is overriding an existing `Food` item
** Cons:
*** Additional command has to be created just to handle editing
*** More tedious for user since more steps are required to achieve the same result.

==== Summary
The `update` command is a smart command that either updates an existing `Food` item in the `FoodRecord` with new nutritional information,
or updates a new `Food` item into the `FoodRecord`
The following activity diagram summarises what happens when a user enters a valid `update` command:

.Activity Diagram for Update command
image::UpdateActivityDiagram.png[]

=== Real-time Suggestions for Existing `Food` in `FoodRecord`

This section addresses how the GUI Result Display suggests Food with similar names to the user for the commands `update`, `delete` and `nom`.

When the user have many `Food` entries in the `FoodRecord`, they may have difficulties finding out if a particular `Food` exists in the `FoodRecord`.
For better user experience, this feature listens to the input of the user for these three commands suggests similar existing Food entries in real time.

This feature listens to the input of the user after the `Prefix` `n/` and checks if there is a `Food` entry in the `FoodRecord` with a similar `Name`.

[NOTE]
The `Name` parameter is case-insensitive and searches the `Food` entries in the `FoodRecord` by whether they start with the user input so far after the
`Prefix` `n/`.

==== Implementation

A listener set in place within the CommandBox to listen for user input passes the input to MainWindow.
This feature is then facilitated by an operation `getSimilarfood` in the


image::RealTimeSuggestionSequenceDiagram.png[]
Step1....



==== Design Considerations
===== Aspect: How the suggestions is shown to the user.
* *Alternative 1: (current choice):* ResultDisplay displays the names of similar Food entries in Food Record.
** Pros:

** Cons:

* Alternative 2:* Filter the GUI's Food Record to similar Food entries.
** Pros:
** Cons:


[[Implementation-HelpGuide]]
=== Command guide `help` command

This section addresses how the `help` command works.

The `help` command allows users to reference a summarised version of the User Guide (called the command guide)
containing the usages of the commands and their formats, arranged in alphabetical order. Users may enter an
optional `command word` that filters the displayed command guide.

[NOTE]
`command word` filters out only commands which contain the `command word` as a substring. If no commands contain it
as a substring, an error message will be displayed at the top of the `HelpWindow` and the full command guide will be shown.


==== Implementation
// end::helpcommand[]

To generate a command guide using the `help` command, a `HelpCommand` object generates the relevant command guides
based on the provided `command word` in the input.

The sequence diagram below demonstrates how the `help` command works, should a `command word` of "nom" be provided.

.Sequence Diagram for Help
image::HelpSequenceDiagram.png[]

Step 1: `LogicManager` executes the user input, using `CalgoParser` to realise it is a `help` command, and thus creates
`HelpCommand`

Step 2: `HelpCommand` constructor generates the necessary mapping of command name to the corresponding command guide.

Step 3: `LogicManager` calls the `execute` method on the `HelpCommand` object, which produces the String containing the
relevant command guides. A `CommandResult` object is produced reflecting the response to the `help` command.

- In the above sequence diagram, one possibility shown, where the user provides a `command_word`. `setFilteredGuide`
will attempt to retrieve only relevant command guides, defaulting to a list of all guides if no relevant guides exist.
Otherwise, by default a list of all guides will be provided.

Step 4: The `CommandResult` is eventually passed to `MainWindow`, which then displays the command guide in a separate
window, called `HelpWindow`.

// end::helpcommand[]
<<<

==== Design considerations
===== Aspect: How Help is displayed
* **Alternative 1 (current choice):** `HelpWindow` is displayed as a separate popup.
** Pros:
- User can refer to the command guide in a window separately from Calgo, keeping it present as they use the App.
- Command guide can give a more detailed description of command usage and format as it has more space to display in.
- No internet access is required as all information on commands is stored offline.
** Cons:
- `help` does not redirect to a url containing the most up-to-date User Guide. Changes made to the User Guide
must be updated in `HelpCommand` separately.
- `HelpWindow` might obstruct view of the App upon initially loading it, causing annoyance.
* **Alternative 2:** `HelpWindow` is not used, and instead content is displayed as part of `ResultDisplay`.
** Pros:
- No possibility of a popup blocking the main app.
- All information is contained within a single window.
** Cons:
- User must use the `help` command every time they require a guide, as `ResultDisplay` will be
overwritten after other commands.

===== Aspect: Command guides can be selectively displayed
* **Alternative 1 (current choice):** `help` displays all command guides by default. User can selectively filter to
display only desired commands by entering an optional keyword after `help`.
** Pros:
- Desired command can be more rapidly found.
- Removes all unwanted commands from `HelpWindow`, reducing clutter.
** Cons:
- Filtered `help` does not benefit users who don't know the command they're looking for.
* **Alternative 2:** Always display all command guides to ensure user will find the guide they require.
** Pros:
- No possibility of user being unable to find their desired command after sufficient searching.
** Cons:
- Relatively large array of commands can be overwhelming to a new user, deterring them from using the App.
- Can be very frustrating to search through for experienced users.

==== Summary
`help` will produce a popup, displaying a guide on the App's available commands' purposes and usage format.

.Activity Diagram for Help
image::HelpActivityDiagram.png[]

<<<


<<<

<<<





// tag::caloriegraph[]
[[Implementation-CalorieGraph]]
=== Past seven days calorie data graph
(by Janice)

This section addresses how the graph displaying the user's past seven day's daily total calorie consumption works.
Note that the graph counts starting from the date on the current `Food Record`, and the six days prior to it.

The graph will always display the past seven days' data at the bottom of the app, and will update
whenever app data is changed.

[NOTE]
If a command changes the date of the `Food Record` (such as `nom` or `stomach`), the graph will update to show data
for the past seven days from that date, inclusive.

==== Implementation
`GraphPanel` in the `Ui` component. It contains a `LineChart` of `String` date against `Number` calories, and is populated with
data from an `XYChart.series`. The data is in turn obtained from the `Logic` component, which provides only the past seven days'
of `DailyFoodLog`. The implementation of the `GraphPanel` class will be further explained.

`GraphPanel` class implements the following operations:

* `GraphPanel#initialiseTreeMap(Logic logic)` - Sets up the TreeMap that maps `LocalDate` date of `DailyFoodLog` to the `Double`
total calorie consumption n that day.
* `GraphPanel#initialseGraph()` - Sets up the `LineChart` with xAxis a `String` representing date, and yAxis a `Double` representing
total calories consumed on that date.
* `GraphPanel#updateSeries()` - Ensures the `XYChart.series` that populates the graph with data is always updated with the
most recent app data.
* `GraphPanel#makeGraph(Logic logic)` - Wrapper function that calls the above three methods.
* `GraphPanel#getGraph(Logic logic)` - Public accessor function to generate and retrieve the `LineChart`.

Calgo will display the past seven days' graph automatically, and likewise update automatically. It does so by having `MainWindow`
call `GraphPanel#getGraph(Logic logic)` on startup and after execution of commands.

The sequence diagram below demonstrates how the `Graph` feature works, such as upon loading of `MainWindow`.

image::GraphSequenceDiagram.png[]
Sequence Diagram for `Graph` feature.

Step 1: `MainWindow` requests for an instance of `GraphPanel`.

If no instance exists, a new `GraphPanel` is created. Otherwise one is retrieved. This ensures that `GraphPanel`
is a singleton.

Step 2: `MainWindow` calls `GraphPanel` again to generate the graph and add it to the `GraphPanelPlaceholder` inside `MainWindow`.

Step 3: Inside `GraphPanel`, a wrapper method `makeGraph` calls three methods in a row:

First, `initialiseTreeMap`, which has `Logic` call the `getPastWeekLogs` method onto `GraphPanel`, generating
a `TreeMap` of `String` date mapped to `Double` calories using the past seven days' `DailyFoodLog`.
Second, `initialiseGraph` method is called to generate the graph itself.
Third, `updateSeries` method is called to ensure the data populating the graph is up to date.

After which, the `GraphPanel` adds the graph to `MainWindow`.

<<<

==== Design considerations

===== Aspect: Choice of visuals for past seven days summary

* *Alternative 1 (current choice):* Summary is represented using a line graph.

* *Alternative 2:* Summary is represented in a table.

===== Aspect: When graph's dates are based on

* *Alternative 1 (current choice):* Dates are based on past seven days starting from date of `Consumption Record`, inclusive.

* *Alternative 2:* Dates are based on past seven days starting from today's date, inclusive.





=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>> below)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the App
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size


[[Implementation-Configuration]]


=== Configuration

Certain properties of the App can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).



== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* Can type fast
* Is reasonably comfortable using `CLI` Apps
* Wants to have, or already has, a lifestyle of eating healthy
* Manages a significant number of `Food` items
* Prefers desktop Apps over other types
* Prefers typing over mouse input

*Value proposition*:

* *Insights:* set goals, generate consumption reports and view progress and statistics
* *Hassle-Free Convenience:* conveniently handles entry conflicts, tolerates incomplete search inputs and produces fast responses
* *Flexibility:* generate Food records as a portable file, tracking wherever, whenever, without a device
* *Efficiency:* manage caloric tracking faster than a typical mouse/GUI driven App

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (possible future development) - `*`

[width="100%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |user who does not know what my food is made of |find out the nutritional composition of a particular food by name |locate details of the entry without having to go through the entire record.

|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App.

|`* * *` |user |have a portable, editable, and readable file to store the relevant values for each entry made |edit, share, or print my personal entries.

|`* * *` |user who may not be able to access his laptop at some time |have a copy of my past entries |use it for physical reference.

|`* * *` |user who dislikes sieving through information and prefers to have only the relevant information presented |have a way to easily find the entries I want in the record |save time and effort and not get annoyed.

|`* * *` |lazy user who does not like typing too many tedious characters |find entries using incomplete words or phrases |obtain the same intended results for a search through the entries as in the case of typing fully and correctly.

|`* * *` |user who dislikes memorising things |have an option to see the entire record |know what entries currently exist in the records.

|`* * *` |user who has many entries |view entire record in lexicographical order |easily navigate to the entry I want in the record.

|`* * *` |user who is forgetful | be able to edit the nutritional value of a previously saved entry in the record | edit the entry if I remembered a nutrition value wrongly previously.

|`* * *` |user who is busy | be able to create a list of goto Food with nutritional values| quickly choose a Food Item with preset values and add it to my calorie tracker.

|`* * *` |user who doesn't like redundant things | override a Food entry in the Food Record which already exists| save time and effort and not create a duplicate item in the Food Record.

|`* * *` |user who gets bored of food easily |delete a Food item that I no longer want to eat in future from my Food Record| avoid having so many Food items in the Food Record that I no longer eat.

|`* * *` |user who is a foodie | find out the statistics of the food that I have been consuming each day | systematically cut down on overeaten food and monitor progress.

|`* * *` |user who cannot decide on what to eat | obtain a list of personalised food recommendations that still align with my dietary goals | avoid wasting time deciding what to eat nor will I give in to impulse and eat junk food.

|`* * *` |user who is interested to lose weight | find out the number of calories I have consumed each day | check which days I have exceed my desired number of daily calorie and exercise more to compensate.

|`* * *` |user who is busy | obtain an easy-to-understand consumption report | quickly understand my food consumption patterns and make plans to rectify them accordingly.

|`* * *` |user who remembers the big picture but not the specifics | search for a particular part of a guide | not be bothered by unnecessary information.

|`* * *` | user who values visuals | curated information expressed in a well organised graph | intuitively understand information.

|`* * *` | user who values opinions | have some suggestions based on my goals and consumption patterns | know my options when I am indecisive on what to eat.

|`* * *` |user who cannot fully remember the name for a particular entry |view all entries which have the nutritional value I happen to remember |obtain a list of possible Food entries that are relevant.

|`* *` |forgetful user | be able to lookup exact command formats | so that I won't need to go through the trouble of memorising commands.

|=======================================================================

As you continue developing the Calgo, feel free to add more user stories here.

[appendix]
== Use Cases

For all use cases below, the *System* is the Calgo application and the *Actor* is the user, unless specified otherwise. +

Also note that the term *MSS* refers to the Main Success Scenario for each Use Case.

[discrete]

=== Use case: obtain reference for app's commands

*MSS*

1.  User requests for a guide on the app's commands.
2.  Calgo shows a list of all available commands and their corresponding purpose and usage.
+
Use case ends.

[discrete]
=== Use case: `find` `Food` item by `Name` or `Tag` keyword (which can be an incomplete word)

*MSS*

1.  User wants to find a `Food` entry by a specific keyword in `Name` or `Tag`.
2.  User enters `find` command with the `Name` `Prefix`, or the `Tag` `Prefix`, accordingly.
3.  Calgo shows a list of `Food` entries which contains the substring indicated in any part of the `Name` or `Tag` of the `Food` entries respectively.
+
Use case ends.

*Extensions*

[none]
*2a. User enters invalid input for particular `Prefix`* +
2a1. A message prompting the user to enter a valid input is shown. +
Use case resumes from Step 2.

*3a. The `FoodRecord` is empty* +
3a1. A message is shown indicating that there are zero matching `Food` items and prompts users to make new entries. +
Use case ends.

[discrete]
=== Use case: `find` `Food` item by nutritional value

*MSS*

1.  User wants to `find` a `Food` item by a single nutritional value of either `Calorie`, `Protein`, `Carbohydrate`, or `Fat`.
2.  User enters `find` command with appropriate `Prefix`.
3.  `Calgo` shows a list of `Food` entries which has the same nutritional value.
+
Use case ends.

*Extensions*

[none]
*2a. User enters invalid input for particular `Prefix`* +
2a1. A message prompting the user to enter a valid input is shown. +
Use case resumes from Step 2.

*3a. The `FoodRecord` is empty* +
3a1. A message is shown indicating that there are zero matching `Food` items and prompts users to make new entries. +
Use case ends.

[discrete]
=== Use case: `export` current `FoodRecord`

*MSS*

1.  User wants to `export` the current `FoodRecord`.
2.  User enters the `export` command into `Calgo`.
3.  Calgo creates a user-friendly text file `FoodRecord.txt` containing all `Food` item details in the `data/exports` folder.
+
Use case ends.

*Extensions*

[none]

*3a. User's system prevents the file from being created* +
3a1. A message is shown indicating that the file is unable to be created. +
Use case ends.

[discrete]
=== Use case: `list` all current `Food` entries

*MSS*

1.  User wants to `list` all current `FoodRecord` entries.
2.  User enters the `list` command into `Calgo`.
3.  `Calgo` shows a list of all `Food` entries in the GUI's `Food Record`.
+
Use case ends.

*Extensions*

[none]
*3a. The `FoodRecord` is empty.* +
3a1. `Calgo` shows a message indicating that all entries are shown, with the GUI showing an empty `Food Record`. User is also prompted by this message to make new entries. +
Use case ends.

[discrete]
=== Use case: `update` current `FoodRecord` with a new `Food` item

*MSS*

1.  User requests to add a new `Food` item in the `FoodRecord`.
2.  `Calgo` creates and saves a new `Food` item in the `FoodRecord` with nutritional information specified by user.
+
Use case ends.

[discrete]
=== Use case: `update` an existing `Food` item in current `FoodRecord`

*MSS*

1.  User requests to edit an existing `Food` item in the `FoodRecord`.
2.  `Calgo` replaces the existing `Food` item's nutritional values with the new information.
+
Use case ends.

[discrete]
=== Use case: `delete` an existing `Food` item in current `FoodRecord`

*MSS*

1.  User requests to delete an existing `Food` item from the `FoodRecord`
2.  Calgo deletes the existing `Food` item in the `FoodRecord`.
+
Use case ends.

[discrete]
=== Use case: set a daily `goal`

*MSS*

1. User enters the `goal` command with the intended value.
2. Calgo updates the user's `goal` to the new value provided by the user.

Use case ends.

*Extensions*

*1a. User enters an invalid input for the `goal`.* +
  1a1. Calgo shows a message indicating the acceptable range of values for the `goal` command. +
  1a2. User enters `goal` command with a new value. +
Steps 1a1 and 1a2 are repeated until user enters a valid input. +

Use case resumes from step 2.


[discrete]
=== Use case: generate a `report` on a specific `date`.

*MSS*

1. User enters the `report` command with a particular `date`.
2. Calgo analyses the `Food` consumed on that `date` and generates a `report` text file in the `data/reports` folder for the user.

Use case ends.

*Extensions*

*1a. There is no `Food` consumed on the inputted `date`.* +
1a1. Calgo shows a message indicating that there was no `Food` consumed on the given `date`. +

Use case ends.

*1b. Inputted `date` in wrong format.* +
1b1. Calgo shows a message indicating the correct format for the `date`.
1b2. User enters `report` command with the `date` in the correct format. +

Use case resumes from step 2.

*1c. User enters `report` command without setting a daily calorie `goal`.* +
1c1. Calgo generates a `report` without the sections related to the `goal`. +

Use case ends.


[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 `Food` items without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Calgo should work on both 32-bit and 64-bit environments.
.  The product expects users to initially find out about `Food` items and their respective nutritional values for creating `Food` item entries for the first time.
.  The minimum screen size for the App window to fully display its GUI is 1250 x 600.
.  The product should be for a single-user.
.  The product should be developed incrementally over the project duration.
.  The software should follow the OOP.


[appendix]
== Glossary

[[command-line-interface]] Command Line Interface (CLI)::
Text-based user interface used to view and manage computer files.

[[food]] Food::
`Food` items entered by the user to represent a real life Food.
This contains nutritional values of each of their `Calorie` s, number of grams of `Protein` s, `Carbohydrate` s and `Fat` s.
They can also contains a series of `Tag` s.

[[gui-food-records-entry]] Food Entry::
An entry in the GUI's `Food Record` box, which shows all details for one `Food` object.

[[food-records]] FoodRecord::
The accumulated list of all `Food` objects entered by the user.

[[gui-food-records]] Food Record::
The GUI's `Food Record` box, which shows all details for every `Food` entry.

[[gui]] GUI::
The Graphical User Interface of Calgo.

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X.

[[nutritional-info]] Nutritional Information::
Refers to `Calorie` s, `Protein` s, `Carbohydrate` s and `Fat` s.

[[oop]] OOP::
Objected-Oriented Paradigm.

[[prefix]] Prefix::
A set of characters placed before a parameter when entering a command.


[appendix]
== Instructions for Manual Testing

Given below are instructions to test the App manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the App by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

=== Deleting a `Food`

. Deleting a `Food` item from the `FoodRecord`

.. Prerequisites: Launch Calgo successfully and a `Food` item Apple already exists in `FoodRecord`
.. Test case: `delete n\Apple` +
   Expected: `Food` item Apple is deleted from `FoodRecord`. Details of the deleted `Food` shown in the status message.
.. Test case: `delete 0` +
   Expected: No food is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete n/Banana` (where `Food` banana does not exists in `FoodRecord`) +
   Expected: Similar to previous.


=== Listing all `Food` entries

. Listing down all entries, regardless of previous commands
.. Prerequisites: Launch Calgo successfully.
.. Test case: `list` +
Expected: The GUI will show all `Food` entries existing in the `FoodRecord`.

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_

[appendix]
== Effort

=== Challenges and Difficulties

At the start, all of us were very new to software engineering projects. Hence, the learning curve was very steep. Because of this, most of the time, we were very confused. However, we demonstrated good teamwork because we always met often and helped each other out by explaining frameworks and teaching each other on software development tools like Git, Intellij and JavaFX.

Due to the COVID-19 situation, there was a lot of uncertainty and our style of meetings were significantly affected. However, everyone demonstrated good attitude and the team was full of good sports, so we covered each other's weaknesses and supported one another, therefore being able to realise a strong team potential.

=== Effort put in by the team

* 3-4 meetings weekly on average
* Many unrecorded hours were put in for self-learning and managing the project.
* We placed a lot of emphasis on brainstorming our features and implementing them to make it user-centric. For e.g. a real-time suggestion feature

=== Achievements

* Product Design
** Our team successfully morphed AB3 and its relevant tests into the Calgo you see today.
** Our team’s project idea was validated and appreciated by peers and tutors, most notably from our CS2101 presentation, CS2103T demo and PE-Dry Run testing.
It also has potential to be collaborated with other peer projects such as FitBiz (Group F11-2).
* Implementation
** Ambitious in experimenting with new interesting features. For e.g. intelligent insights and graphs.
** Implemented features consistently and incrementally, allowing us to make changes to past features and
** Experimented with new workflow before deciding on one, Agile(Scrum), which we liked the most.
** Put in additional effort in making the GUI different and novel, even though it is not part of the grading rubric. This is another example of how we go the extra mile to make our product more user-centric. For e.g. we tried out new JavaFX APIs like LineChart and TableView.
* Project Management
** Predominantly followed the forking workflow.
** Diligently created issues and assigned them on GitHub, while also consistently communicating with each other on Telegram.
** Planned and incrementally implemented our user stories throughout different milestones.
** Regularly reviewed each other’s code on and off Github.

